<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Mohit Sharma</title>
    <link>/post/</link>
    <description>Recent content in Posts on Mohit Sharma</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>&amp;copy; 2017 Mohit Sharma</copyright>
    <lastBuildDate>Sun, 01 Jan 2017 00:00:00 +0000</lastBuildDate>
    <atom:link href="/post/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>lets encrypt Nginx</title>
      <link>/post/lets-encrypt-nginx/</link>
      <pubDate>Thu, 11 Aug 2016 00:00:00 +0000</pubDate>
      
      <guid>/post/lets-encrypt-nginx/</guid>
      <description>

&lt;p&gt;Encrypting the web traffic is a standard practice today. It is used by almost everyone regardless of whether you are a Bank making sure your customers feel safe to use online services, an e-commerce website trying to gain the confidence of your customers or just another blog writer who wants to look cool with the nice green lock in the address bar. In today&amp;rsquo;s world and with the recent developments/ enhancements in the TLS security (check the draft for v1.3 here &lt;a href=&#34;https://tlswg.github.io/tls13-spec/&#34; target=&#34;_blank&#34;&gt;https://tlswg.github.io/tls13-spec/&lt;/a&gt;) and especially with the launch of &lt;a href=&#34;https://letsencrypt.org/&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;Let&#39;s Encrypt&lt;/code&gt;&lt;/a&gt;, there is only one reason to not encrypt your webtraffic.. Laziness! and No, encrypting all your traffic is not computationally heavy. So even if you are running your blog or any webservice on a $5/month 512MB droplet from digitalocean, you should be fine!&lt;/p&gt;

&lt;p&gt;Anyways, so why did I make this move now? Call me stingy but I just cannot open my wallet to pay for services. However to my excitement, I got the &lt;a href=&#34;http://thehackernews.com/2016/03/lets-encrypt-free-ssl-certificate.html&#34; target=&#34;_blank&#34;&gt;news&lt;/a&gt; about a new certificate authority &lt;a href=&#34;https://letsencrypt.org/&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;Let&#39;s Encrypt&lt;/code&gt;&lt;/a&gt;which offers free SSL certificate! (well only 20 per domain per week but that&amp;rsquo;s, frankly, quite enough!). Anyways thats was it for me.. Now, I HAD to do it. I decided to use the &lt;code&gt;Webroot&lt;/code&gt; plugin. There are many other methods but I find this to be quite straightforward.&lt;/p&gt;

&lt;h2 id=&#34;what-is-webroot&#34;&gt;What is Webroot?&lt;/h2&gt;

&lt;p&gt;Let&amp;rsquo;s Encrypt provides a number of ways to obtain SSL certificates and install it for different webservers such as &lt;a href=&#34;https://certbot.eff.org/about/&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;certbot&lt;/code&gt;&lt;/a&gt; which is a client tool to fetch and deploy the SSL/ TLS certificates based on the webserver that you are using. &lt;br/&gt;
&lt;a href=&#34;https://certbot.eff.org/docs/using.html#webroot&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;Webroot&lt;/code&gt;&lt;/a&gt; is actually a plugin for the &lt;a href=&#34;https://certbot.eff.org/&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;certbot&lt;/code&gt;&lt;/a&gt; which allows you to obtain the SSL certificate. The way it works is by placing a special file &lt;code&gt;.well-known&lt;/code&gt; in the webserver&amp;rsquo;s serving root location (like inside /usr/share/nginx/html/ or /var/www/html/. If you don&amp;rsquo;t remember it then check the &lt;code&gt;/etc/nginx/sites-available/default&lt;/code&gt; configuration file and look for where document &lt;code&gt;root&lt;/code&gt; points to).&lt;/p&gt;

&lt;p&gt;Installing the certificate, however, is left upto the user. &lt;br/&gt;
I use Nginx for serving all my web requests so this post is specifically for nginx. &lt;br/&gt;let&amp;rsquo;s start with the process of encrypting all your web traffic. I am assuming you have: &lt;br/&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Root access to the server&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Have A record updated in DNS settings (check with your domain name provider like godaddy, namespace etc) and it correctly points to your server&amp;rsquo;s ip address&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Some familiarity with Nginx and its configuration files&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Your favorite for a text editor (I use &lt;code&gt;emacs&lt;/code&gt;.. so replace &lt;code&gt;emacs -nw&lt;/code&gt; with your favorite text editor)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Maybe a coffe, if you fancy&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;step1-installing-let-s-encrypt&#34;&gt;Step1 : Installing Let&amp;rsquo;s Encrypt&lt;/h2&gt;

&lt;p&gt;Best way, as of now, to get the Let&amp;rsquo;s Encrypt client  is to clone the &lt;code&gt;master&lt;/code&gt; branch from their github repository in root&amp;rsquo;s home directory&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;~#&amp;gt; git clone https://github.com/letsencrypt/letsencrypt ~/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;OR&lt;/strong&gt;
another way would be to get a slightly old version using &lt;code&gt;apt-get&lt;/code&gt; package manager&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;~#&amp;gt; apt-get install letsencrypt
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;step2-nginx-configuration-for-webroot&#34;&gt;Step2: Nginx configuration for Webroot&lt;/h2&gt;

&lt;p&gt;Remember we talked about &lt;code&gt;.well-known&lt;/code&gt; file that is used by Webroot plugin to validate the authenticity of your webserver? Lets put that in nginx configuration so that when Let&amp;rsquo;s Encrypts services try to run the check, they should be able to see the file.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;~#&amp;gt; sudo emacs -nw /etc/nginx/sites-available/default
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and inside the server block add another location:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;location ~ /.well-known {
                allow all;
	}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Reload nginx&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;~#&amp;gt; systemctl reload nginx
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;step3-obtaining-ssl-certificate&#34;&gt;Step3 : Obtaining SSL Certificate&lt;/h2&gt;

&lt;p&gt;Like I mentioned before, we will be using &lt;code&gt;Webroot&lt;/code&gt; plugin to obtain SSL certificate&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;~#&amp;gt; cd letsencrypt
~#&amp;gt; ./letsencrypt-auto certonly -a webroot --webroot-path=/usr/share/nginx/html -d example.com -d www.example.com
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;Replace example.com with your website name.
certonly: only grab SSL certificate
webroot: top-level root directory (&amp;ldquo;web root&amp;rdquo;) same as what is configured in nginx&amp;rsquo;s configuration file (&lt;code&gt;/etc/nginx/sites-available/defalt&lt;/code&gt;)
d: domain name&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Answer the questions and in the end you should see a note which says something like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;IMPORTANT NOTES:
- If you lose your account credentials, you can recover through e-mails sent to your@email.com

- Congratulations! Your certificate and chain have been saved at
    /etc/letsencrypt/live/example.com/fullchain.pem. Your cert will expire on 2016-11-10. To obtain a new version of the certificate in the future, simply run Let&#39;s Encrypt again.

- Your account credentials have been saved in your Let&#39;s Encrypt configuration directory at /etc/letsencrypt. You should make a secure backup of this folder now. This configuration directory will also contain certificates and private keys obtained by Let&#39;s Encrypt so making regular backups of this folder is ideal.

- If like Let&#39;s Encrypt, please consider supporting our work by:
   Donating to ISRG / Let&#39;s Encrypt:   https://letsencrypt.org/donate
   Donating to EFF:                    https://eff.org/donate-le

&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;Make sure to note that the certificate that you received is only good for 90 days. After which you will have to run the script again. Hold on to that thought, we will talk more on that and write a script to automate this task for us :)
Also note the location where the server&amp;rsquo;s pvt key and certificates are generated. We will need them in next step&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;step4-generate-diffie-hellman-group&#34;&gt;Step4: Generate Diffie-Hellman Group&lt;/h2&gt;

&lt;p&gt;To strengthen the security even further, lets generate a nice 4096bit DH group whih allows two devices to establish a shared secret over an unsecure communications channel.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;~#&amp;gt; openssl dhparam -out /etc/ssl/certs/dhparam.pem 4096
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;This might take a moment&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;step5-nginx-file-configurations&#34;&gt;Step5: Nginx File Configurations:&lt;/h2&gt;

&lt;p&gt;Before we proceed, make a backup! (Not shown here)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;~#&amp;gt; cp /etc/nginx/sites-available/default /etc/nginx/sites-available/default.bak
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;~#&amp;gt; emacs -nw /etc/nginx/sites-available/default
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now, assuming you have default configuration, make a server block on top of the existing server block. It should look like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;server {
    listen 80 default_server;
    listen [::]:80 default_server;
    server_name example.com www.example.com;
    return 301 https://$server_name$request_uri;
    }

server {
       ... &amp;lt;your old stuff&amp;gt; 
       ...
       }
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;Make sure to replace example.com with your website domain name&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Now in the second server block, add these lines:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;server {
       # SSL configs
       listen 443 ssl http2 default_server;
       listen [::]:443 ssl http2 default_server;
       ssl_certificate /etc/letsencrypt/live/example.com/fullchain.pem;
       ssl_certificate_key /etc/letsencrypt/live/example.com/privkey.pem;
       }
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;Make sure to replace example.com with your website domain name&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&#34;https://cipherli.st/&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;Cipherli.st&lt;/code&gt;&lt;/a&gt; provides a nice &amp;ldquo;suggested settings&amp;rdquo; for stronger security. Grab the information for nginx and put that in the second server block.&lt;br/&gt;
Finally, your configuration should look something like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;server {
        isten 80 default_server;
       	listen [::]:80 default_server;
        server_name example.com www.example.com;
	return 301 https://$server_name$request_uri;
       }

server {
        # SSL configs
        listen 443 ssl http2 default_server;
        listen [::]:443 ssl http2 default_server;
        ssl_certificate /etc/letsencrypt/live/example.com/fullchain.pem;
        ssl_certificate_key /etc/letsencrypt/live/example.com/privkey.pem;

	# Forcing better security
	ssl_protocols TLSv1 TLSv1.1 TLSv1.2;
	ssl_prefer_server_ciphers on;
	ssl_ciphers &amp;quot;EECDH+AESGCM:EDH+AESGCM:AES256+EECDH:AES256+EDH&amp;quot;;
	ssl_ecdh_curve secp384r1; # Requires nginx &amp;gt;= 1.1.0
	ssl_session_cache shared:SSL:10m;
	ssl_session_tickets off; # Requires nginx &amp;gt;= 1.5.9
	ssl_stapling on; # Requires nginx &amp;gt;= 1.3.7
	ssl_stapling_verify on; # Requires nginx =&amp;gt; 1.3.7
	resolver &amp;lt;DNS-IP-1&amp;gt; &amp;lt;DNS-IP-2&amp;gt; valid=300s;
	resolver_timeout 5s;
	# Remove preloading!
	#add_header Strict-Transport-Security &amp;quot;max-age=63072000; includeSubDomains; preload&amp;quot;;
	add_header Strict-Transport-Security &amp;quot;max-age=63072000; includeSubDomains;
	add_header X-Frame-Options DENY;
	add_header X-Content-Type-Options nosniff;

	# Adding DH group
	ssl_dhparam /etc/ssl/certs/dhparam.pem;
       }
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;Remember to replace &lt;DNS-IP-1&gt; and &lt;DNS-IP-2&gt; with your preferred choice
Also remember to disable preloading unless you know what you are doing
Add DH group in the end&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;step-6-almost-done&#34;&gt;Step 6: Almost done..&lt;/h2&gt;

&lt;p&gt;Restart nginx and check if it works&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;~#&amp;gt; systemctl restart nginx
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;step7-auto-renewing&#34;&gt;Step7: Auto Renewing!&lt;/h2&gt;

&lt;p&gt;It would be a pain to first of all remember to renew the certificate every 90 days and then making sure that I do! Instead what we&amp;rsquo;ll do is set up a cronjob that will be triggered every Saturday at night 1am.&lt;/p&gt;

&lt;p&gt;The command to renew the certificate is&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;~#&amp;gt; ./letsencrypt-auto renew
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;If you run this now, you should see a message saying &lt;code&gt;No renewals were attempted&lt;/code&gt; since we just installed the certificate.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Let&amp;rsquo;s created a cronjob&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;~#&amp;gt; crontab -e
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Following is the format for crontab&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1. Entry: Minute when the process will be started [0-60]
2. Entry: Hour when the process will be started [0-23]
3. Entry: Day of the month when the process will be started [1-28/29/30/31]
4. Entry: Month of the year when the process will be started [1-12]
5. Entry: Weekday when the process will be started [0-6] [0 is Sunday]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So, if we want to schedule this task for every Saturday at 1am, the format should look like:
&lt;code&gt;0 1 * * 6&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;the crontab entry would be:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;0 1 * * 6 /root/letsencrypt/letsencrypt-auto renew &amp;gt;&amp;gt; /var/log/ssl-renew.log
5 1 * * 6 /bin/systemctl reload nginx
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;Always reload nginx service so that new process is started first and then the old one is terminated. Restarting the nginx kills the old process first so it might happen that there was some error and your nginx server doesn&amp;rsquo;t come back up!&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;That&amp;rsquo;s &lt;strong&gt;literally&lt;/strong&gt; it! You now have an encrypted web traffic to and from your server in just 7 steps! Enjoy&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>jupyter notebooks in blog</title>
      <link>/post/jupyter-notebooks-in-blog/</link>
      <pubDate>Tue, 12 Jul 2016 00:59:02 -0400</pubDate>
      
      <guid>/post/jupyter-notebooks-in-blog/</guid>
      <description>&lt;p&gt;I love Jupyter notebooks! They are great for experimenting and playing around with the ideas. I always liked the idea of using a single web based application for writing code snippets, visualizations, creating presentations and even blogging! &lt;br/&gt;
There are great static website generators out there but most of them use restructured text or markdown to convert to html pages. 
&lt;br&gt;
Developers of jupyter notebooks have now embedded the nbconvert tool for converting notebooks (&lt;code&gt;ipynb&lt;/code&gt;) to Markdown (&lt;code&gt;md&lt;/code&gt;) or ReStructuredText (&lt;code&gt;reST&lt;/code&gt;) and even standalone &lt;code&gt;html&lt;/code&gt; with all the css stylings. Regardless of whether you use blogging engines like &lt;a href=&#34;https://wordpress.com/&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;Wordpress&lt;/code&gt;&lt;/a&gt; or static website generators like &lt;a href=&#34;https://gohugo.io/&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;Hugo&lt;/code&gt;&lt;/a&gt;, the issue of formatting the notebook so that they play well with your website has always persisted.&lt;/p&gt;

&lt;h2 id=&#34;using-jupyter-notebooks-in-your-blog&#34;&gt;Using Jupyter notebooks in your blog&lt;/h2&gt;

&lt;p&gt;I&amp;rsquo;ve always had two options:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Convert Notebooks to Markdown&lt;br/&gt;
Use Jupyter notebook&amp;rsquo;s built-in command to convert to markdown and then spend 20 more minutes correcting formatting, image&amp;rsquo;s that are embedded, code blocks, etc. I would then convert to html using &lt;a href=&#34;https://gohugo.io/&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;Hugo&lt;/code&gt;&lt;/a&gt; or &lt;a href=&#34;http://blog.getpelican.com/&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;Pelican&lt;/code&gt;&lt;/a&gt; website generator (based on what I am using for my website) and then publish it online.  Problem with this method? Formatiing, Code samples, Code coloring, everything lost!&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Convert Notebooks directly to html&lt;br/&gt;
Use Jupyter notebook&amp;rsquo;s built-in command to convert to html and use it in my blog. Issues with this? Horrible CSS! Don&amp;rsquo;t get me wrong. The html output from Jupyter&amp;rsquo;s nbconvert was meant to provide a decent layout and styling for a standalone professional html file.. and it does that well. However if you are like me, you have some global layout style that you want your notebook in.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;available-tools&#34;&gt;Available Tools&lt;/h2&gt;

&lt;p&gt;I have used:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://github.com/danielfrg/pelican-ipynb&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;pelican-ipynb&lt;/code&gt;&lt;/a&gt; plugin for blogging using ipython (or Jupyter) notebook. However I had a hard time setting it up. Plus there were some incompatibilities with the themes that I was using. It is a good tool and you can check it out here: (&lt;a href=&#34;https://github.com/danielfrg/pelican-ipynb&#34; target=&#34;_blank&#34;&gt;https://github.com/danielfrg/pelican-ipynb&lt;/a&gt;) but I wanted something that would.. Just.. Work!&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://getnikola.com/blog/&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;Nikola&lt;/code&gt;&lt;/a&gt; static website generator just like &lt;code&gt;Hugo&lt;/code&gt; and &lt;code&gt;Pelican&lt;/code&gt;. It has an added advantage that it supports blogging via notebooks right out of the box. Sweet! but it is really targeted at making a blog first that means main page always seems to be the blogroll. Whereas I wanted a single page academic website having my intro on top and publications and then posts with some kind of blogroll in there. Anyways it really felt targeted towards a blog site or a site with lots of posts. Moreover it uses &lt;a href=&#34;http://www.makotemplates.org/&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;Mako&lt;/code&gt;&lt;/a&gt; templating engine whereas I was more familiar with &lt;a href=&#34;http://jinja.pocoo.org/&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;jinja&lt;/code&gt;&lt;/a&gt; and &lt;a href=&#34;https://golang.org/pkg/html/template/&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;Go&lt;/code&gt; template library&lt;/a&gt;. Anyways in the end, I decided to stick with either &lt;code&gt;Pelican&lt;/code&gt; or &lt;code&gt;Hugo&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;I have spent enough hours trying to google and reading forums to realize that there is no one tool to solve it all. In the end I decided to do this manually. I opened chrome developer tools and started analyzing the generated html page. &lt;br/&gt;
Stripping away as much css styling as possible, I was finally able to create a barebones version of css styling that can be used with the exported html page  (from notebook using nbconvert).
&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;Now whenever you want to embed your notebook in your blog, you can simply:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Convert the jupyter notebook to basic html file:
&lt;code&gt;
jupyter nbconvert --to html --template basic *source_file.ipynb* *target_file.html*
&lt;/code&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Download the &lt;a href=&#34;http://sharmamohit.com/css/jupyter.css&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;jupyter.css&lt;/code&gt;&lt;/a&gt; file and place it in your css folder of your website.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Now simply modify your base index html file or whatever it is that contains the boiler plate/ placeholder for your website by adding a css tag linking to this file.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;That&amp;rsquo;s it!&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>
